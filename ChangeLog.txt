week 1 : Starting reading and documentating on the Required Knowledge
(16/05/22 -- 22/05/22)
		-- getting information on how to use intel documentation.

		-- getting basic information on how a CPU work.

		-- getting basic information on x86 assembly.

		-- starting tutoriel on how to use objdump.

		-- starting Bran's tutoriel for kernel coding.

week 2 :  Kernel base code session, Understanding basic architecture .
(22/05/22 -- 29/05/22)
		-- finished coding main.c start.s scrn.c link.ld.

		-- figuring out why grub don't load the kernel ("got multiboot header
		missing").

		-- found that multiboot header constants (magic, flags, checksum)
		were not properly initialized in start.s, and start.s had wrong
		extension (.asm instead of .s).

		-- Having a "Hello Kernel World !" printed and working, i will now
		rework on the understanding of the actual architecture. (why these
		work and how they work together)

week 3 : GDT and IDT implementation
(29/05/22 - 05/06/22)
		-- followed Bran's kernel programming tuto but now i will try using
		intel documentation only.

		-- GDT was implemented using the bran's kernel tutoriel
		the IDT will be implemented by myself.

		-- IDT is actually the table used to handle interrupts signals and
		misc. the structure is really close to the GDT.

		-- I finished coding the first Isr "divide by 0 exception" but it
		close my kernel as soon as i open it. after searching for 2 days
		i found that a 0 was placed after a ret instruction, However it 
		didn't fixed the problem.

		-- I think the problem come from my call of isr_set_descriptor, perhaps
		the base adress is wrong. i really need coffee.

		-- I will use bochs to debug my idt and my gdt, but figuring out how
		to use it take me  2 days.

		-- Ok, i finally fixed the idt by rewritting all the program, i think
		the error was in the identifiers of variables and im starting getting
		good at handling bochs

week 4: ISR writing and IRQs mapping
(05/06/22 -07/06/22)
		-- Ok so i pre-code the interrupt 0 of intel 32-bit documentation
		and i tried to test it, of course with a broken idt it was hard to
		test it, now im facing a new issue (invalid opcode 0x6) thrown by an
		assembly line, a lock push on adress 0008:0x3, don't know why.
		the procco do the following : throwing an exception due to a division
		by 0 (from my test so it's normal), and then throw an invalid opcode
		which is not normal.


